# Протокол для сосятзания ботов
Для участия в состязании ботов вы должны реализовать своё приложение по одному из следующих вариантов:

## Использование посредника botctl (предпочтительный вариант)
Консольное приложение, которое реализует указанную игру и работает по правилам, описанным в [репозитории Вячеслава Иванченко](https://github.com/RobolabGs2/botctl). В этом случае язык программирования не принципиален, главное – работа со стандартными потоками ввода-вывода, и соблюдение простого протокола. Формат хода для каждой конкретной игры указан в форуме на Moodle (курс ИС).

## Использование TCP-клиента
Более сложный вариант, однако позволяет реализовать графический интерфейс. К сожалению, на данный момент TCP-клиент для C++ не реализован (он вообще ни для чего не реализован, кроме PascalABC.NET), потому если у вас есть код для C++ (консольное приложение), и вы хотите прикрутить графику, то можно поступить следующим образом:
1. Преобразовать написанное вами консольное приложение в неуправляемую dll. Заготовка рабочего проекта находится в папке DllProj. Такая Dll должна содержать основную функцию – решение одной текущей позиции и просто выбор хода. На данный момент в DllProj описана функция, принимающая строку, модифицирующая её, и возвращающая назад. Вот эту функцию и поменять таким образом, чтобы она получала строку с текущей позицией, и возвращала строку с указанием выбранного хода. Обратите внимание, что формат этой строки можете выбрать любой, он не обязан совпадать с форматом описания хода или состояния, указанном на Moodle для вашей игры. Да, и собирать в режиме Release, он настроен на вывод dll в папку ReleaseOutput.
2. Исправить проект SolverLib – в нём просто поправить заголовок функции, чтобы он соответствовал той функции SolveState, которую вы подправили (если подправили) под свою игру в проекте DllProj. Проект SolverLib собирает управляемую dll, которую можно вызвать из PascalABC.NET (неуправляемую dll из проекта DllProj просто так не вызвать).
3. Откройте файл TestDll.pas в папке ReleaseOutput и посмотрите как подключать управляему dll к PascalABC.Net (одна строчка, классно же?).
4. Осталось открыть файл TickTackToeBot2.pas и посмотреть, как там всё устроено – там используется TCP-клиент для работы с сервером, и визуализация, разве что собственно решения нет. Вот к нему прикрутить созданную GameAlgs.dll (которая использует CppDll.dll) и получится прекрасное приложение с визуализацией.

## Протокол для работы с TCP-сервером
Клиенты подключаются по адресу localhost:10001, должны себя идентифицировать первой командой `Login`, указав своё имя, и игру. Далее сервер выбирает случайным образом пару игроков для игры - если таковые существуют, и инициирует игру между ними, выбирая случайно очередность хода.

Общение между клиентами происходит посредством строковых команд, символом-разделителем считается символ `%`. Cначала идёт команда – до `%`, только латинские буквы
В своих сообщениях, какие бы они не были, нельзя использовать символ `%`. Если сообщение содержит только команду (без аргументов), то завершающий символ `%` можно не ставить. Предполагается, что символы перевода строки не передаются, признак завершения строки – нулевой символ (это должно по умолчанию работать).

### Список команд (в скобках указывается кто отправляет такую команду)
#### `Login%BotName%Game` (клиент) 
BotName - имя игрока (ну или бота), под которым его видно на сервере. Как напишите, тому баллы и будут начислены (ну, при условии наличия такой персоны в БРС), Game - одно из следующих:
* Infection
* FourInRow
* Reversi
* Gomoku
* Corners
* NineMensMorris
* WolfsAndSheeps

#### Logout (клиент или сервер)
Уведомление о разрыве соединения – отключение от сервера, отправляется клиентом, надоело играть. Также отсылается сервером в том случае, если клиент запросил апелляцию (тогда текущее подключение разрывается, до выяснения).

#### StartFirst и StartSecond (сервер клиенту)
Начать игру, `StartFirst` – клиент ходит первым, `StartSecond` – ждём первого хода противника

#### Move%<сделанный ход> (клиент серверу или сервер клиенту)
Передаётся сделанный ход. Так клиент сообщает о сделанном ходе, либо принимает сообщение о ходе противника. Формат хода должен соответствовать описанному на Moodle.

#### PassMove (клиент или сервер)
Пропуск хода – клиент либо сообщает о пропуске хода, либо получает сообщение от противника о пропуске хода.

#### StopGame (сервер)
Сообщение сервера о принудительном завершении текущей игры (всё, почему-то игра закончилась). Эту команду клиент не должен отсылать сам – иначе дисквалификация.

#### RequestField (сервер клиенту или наоборот)
Запрос текущей конфигурации игрового поля, в ответ на который необходимо отправить поле в формате, соответствующем выбранной игре (см. на Moodle).

#### Field%<сохранённое в виде строки представление поля> (клиент или сервер)
Отправка текущего состояния поля/

#### Все приведённые ниже сообщения заканчивают текущую партию:
Эти сообщения могут быть как отправлены клиентом, так и получены. В случае получения такого сообщения игра завершается, но можно потребовать апелляции.
##### WinGame (клиент или сервер)
Если отсылает клиент, то он объявляет о выигрыше. Если получаем такую команду – значит, мы выиграли.
##### FailGame (клиент или сервер)
Аналогично предыдущему, поражение.
##### DrawGame (клиент или сервер)
Ничья, констатация ничьей.
#### Objection (клиент серверу)
Апелляция. Отсылается клиентом в том случае, если он не согласен с действиями соперника (например, нам прислали команду Если что-то пошло не так, то просьба сохранить в файл логи игры, и рассмотрение судейской коллегией.

#### Служебные сообщения от сервера
`BadRequest` – неправильно сформированное сообщения для сервера. Отправляет сервер в случае, если не смог распознать команду

`LogicError` – логическая ошибка (например, попытка сделать ход в том случае, если игра не инициализирована)

`Info` – информация от сервера

`Score` – информация о текущем счёте игрока
